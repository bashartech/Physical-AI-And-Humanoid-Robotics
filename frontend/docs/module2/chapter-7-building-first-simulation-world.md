---
sidebar_position: 7
---
# Chapter 7: Building first simulation world

### Introduction
This chapter guides you through the process of constructing your very first functional simulation world from scratch using Gazebo. We will cover the essential steps, from defining the world file to adding a basic robot model and simple objects. The goal is to gain hands-on experience and build confidence in setting up a working digital twin environment for a robot.\n
### Main Sections\n\n#### 7.1 Setting Up Your Gazebo Environment\n*   **Theoretical Explanation:** Ensuring Gazebo is installed and configured correctly. Understanding the directory structure for Gazebo models and worlds. Introduction to environment variables like `GAZEBO_MODEL_PATH` and `GAZEBO_RESOURCE_PATH`.\n*   **Key Concepts:** Installation process, `gzserver`, `gzclient`, default worlds.\n*   **Code Example (Concept):** Bash commands for installing Gazebo and setting up environment variables.\n
#### 7.2 Creating a Basic World File (.world)\n*   **Theoretical Explanation:** Structure of a Gazebo `.world` file. Defining the physics engine, gravity, and simulation properties. Adding a simple ground plane and ambient lighting.\n*   **Key Concepts:** XML structure, `<world>`, `<physics>`, `<light>`, `<model>`.\n*   **Code Example (Concept):** The minimal `.world` file for an empty Gazebo scene with a plane and default physics.\n
#### 7.3 Designing and Integrating a Simple Robot Model (URDF/SDF)\n*   **Theoretical Explanation:** Introduction to Universal Robot Description Format (URDF) or Simulation Description Format (SDF) for defining robot kinematics, dynamics, and visual/collision properties. Creating a single-link robot (e.g., a simple box or cylinder) with mass and inertia.\n*   **Key Concepts:** Link, joint, inertia, mass, visual, collision, material.\n*   **Code Example (Concept):** A complete URDF/SDF for a simple one-link robot model with a base link and visual/collision geometries.\n*   **[DIAGRAM: Basic URDF/SDF Structure - Link and Joint]**\n
#### 7.4 Adding Static Obstacles and Interactive Elements\n*   **Theoretical Explanation:** Populating the world with static objects (e.g., walls, tables, blocks) using primitive shapes or simple meshes. Incorporating basic interactive elements like a movable box that the robot can push.\n*   **Key Concepts:** `<static>` tag for models, relative poses, naming conventions.\n*   **Code Example (Concept):** Modifying the `.world` file to include multiple static box models and one non-static cylinder model.\n
#### 7.5 Launching and Verifying Your Simulation World\n*   **Theoretical Explanation:** Using `gazebo` command to launch the world. Inspecting the simulation in `gzclient`. Checking for errors in the terminal output. Confirming physics interactions are as expected.\n*   **Key Concepts:** Command-line arguments, real-time factor, simulation controls (play/pause).\n*   **Code Example (Concept):** Bash commands to launch the created `.world` file.\n
### Practical Assignment\n**Task:** Following the chapter's guidance, create a new Gazebo `.world` file and a corresponding URDF/SDF for a simple robot.\n1.  **World File:** Define a basic world with a ground plane, gravity, and one static box obstacle.\n2.  **Robot Model:** Create a two-link robot (e.g., a base and an arm segment connected by a revolute joint). Ensure each link has appropriate mass, inertia, visual, and collision properties.\n3.  **Launch:** Launch your world in Gazebo and verify that the robot and obstacle appear correctly and interact physically (e.g., if you push the robot against the box, it should collide).\n
### Quiz\n1.  Which command is primarily used to launch the Gazebo client GUI?\n    a) `gzserver`\n    b) `gazebo`\n    c) `roslaunch`\n    d) `gzclient`\n
2.  What is the purpose of the `GAZEBO_MODEL_PATH` environment variable?\n3.  Describe the key components required to define a basic \"link\" in a URDF or SDF file.\n